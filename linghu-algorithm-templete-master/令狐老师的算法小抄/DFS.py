# DFS

# DFS 应用场景
# 找满足某个条件的所有方案(99%)
# 二叉树Binary Tree 的问题(90%)
# 组合问题(95%)
#  ~问题模型：求出所有满足条件的“组合”
#  ~判断条件：组合中的元素是顺序无关的
# 排列问题(95%)
#  ~问题模型：求出所有满足条件的“排列”
#  ~判断条件：组合中的元素是顺序“相关”的

# 不要用DFS 的场景
# 连通块问题（一定要用BFS，否则StackOverflow）
# 拓扑排序（一定要用BFS，否则StackOverflow）
# 一切BFS 可以解决的问题

# 时间复杂度：O(方案个数* 构造每个方案的时间)
# 树的遍历： O(n)
# 排列问题： O(n! * n)
# 组合问题： O(2^n * n)

def dfs(参数列表):
    if 递归出口：
        记录答案
        return
    
    for 所有的拆解可能性：
        修改所有的参数
        dfs(参数列表)
        还原所有被修改过的参数
    return something 如果需要的话，很多时候不需要 return 值除了分治的写法


